# 排序

## 十大排序算法比较图
![image](Utils/sort.png)

## 迭代版本
1. 两个基础排序【选择排序 (Quick)、插入排序 (Selection)】

### 选择排序 (Quick)
- 性质
  - 运行时间和输入无关: 选择排序无视原始数组的顺序。无论是已经有序的数组，还是全等数组，都和打乱的数组是一样的
  - 数据移动是最少的: 每次只交换当前索引元素(arr[i])与剩余数组的最小元素(arr[min])
- 稳定性：不稳定。例：[5,8,9,5,2] -> 第一轮排序会将元素2和5（即a[0]和a[4]）交换 -> [2,5,8,9,5] -> 两个5的相对位置发生变化
- 时间复杂度：因为与数据的原始顺序无关，所以最坏/最好/平均时间复杂度都是O(n^2)
- 空间复杂度：O(1)

### 插入排序 (Selection)
- 性质
  - 插入排序对于部分有序的数组十分高效，也很适合小规模数组
- 稳定性：稳定
- 时间复杂度：最坏O(n^2)，最好O(n)，平均O(n^2)
- 空间复杂度：O(1)

### 希尔排序 (Shell): 也叫递减增量排序
- 性质
  - 希尔排序是对直接插入排序的一个优化，通过主键递减增量，是数组逐渐区仅部分有序。最后对不分有序的数组试用直接插入排序
- 稳定性：不稳定
- 时间复杂度：最坏O(n*(log2n))，最好O(n)，平均O(n*(log2n))
- 空间复杂度：O(1)

### 归并排序 (Merge)
- 归并排序的优化
  - 当数据规模被拆分的比较小后(比如15个)，不再拆分，改用使用插入排序或选择排序进行小规模数组排序
  - merge之前可以先判断，第一个子数组的最后一个元素是不是小于第二个子数组的第一个元素，如果是就可以直接合并
- 时间复杂度：O(n*logn)
- 空间复杂度：O(n)

# 排序

## 迭代版本

1. 两个基础排序【选择排序 (Quick)、插入排序 (Selection)】

## 十大排序算法

### 冒泡排序 (Bubble)

### 选择排序 (Quick)

- 运行时间和输入无关: 选择排序无视原始数组的顺序。无论是已经有序的数组，还是全等数组，都和打乱的数组是一样的
- 数据移动是最少的: 每次只交换当前索引元素(arr[i])与剩余数组的最小元素(arr[min])

#### 稳定性

- 不稳定。例：[5,8,9,5,2] -> 第一轮排序会将元素2和5（即a[0]和a[4]）交换 -> [2,5,8,9,5] -> 两个5的相对位置发生变化

#### 复杂度

- 时间复杂度：因为与数据的原始顺序无关，所以最坏/最好/平均时间复杂度都是O(n^2)
- 空间复杂度：O(1)

### 插入排序 (Selection)

- 插入排序对于部分有序的数组十分高效，也很适合小规模数组

#### 稳定性

- 稳定

#### 复杂度

- 时间复杂度：最坏O(n^2)，最好O(n)，平均O(n^2)
- 空间复杂度：O(1)

### 希尔排序 (Shell): 也叫递减增量排序

- 希尔排序是对直接插入排序的一个优化，通过主键递减增量，是数组逐渐区仅部分有序。最后对不分有序的数组试用直接插入排序

#### 稳定性

- 不稳定

#### 复杂度

- 时间复杂度：最坏O(n*(log2n))，最好O(n)，平均O(n*(log2n))
- 空间复杂度：O(1)

### 归并排序 (Merge)

#### 性质

- 归并排序是无视输入元素的有序性的一种算法

#### 稳定性

- 稳定

#### 复杂度

- 时间复杂度：O(n*logn)
- 空间复杂度：O(n)，额外创建的辅助数组，大小和原数组一样。 O(logn)，递归调用开辟栈空间。-> O(logn)

#### 归并排序的改进

- 当数据规模被拆分的比较小后(5～15)，不再拆分，改用使用插入排序或选择排序进行小规模数组排序
- merge之前可以先判断，第一个子数组的最后一个元素是不是小于第二个子数组的第一个元素，如果是就可以直接合并

### 快速排序 (Quick)

#### 快排基本原理

- 随机取一个待排元素作为切分元素a。用两个指针相对的遍历数组，当左指针i的元素大于a，且有指针j的元素小于a，将i、j指向的元素交换。直到i、j两指针相遇，元素a排好。之后以元素a为切分元素，使用相同方法递归的切分左右两侧数组。

#### 稳定性

- 不稳定

#### 复杂度

- 时间复杂度：平均：O(n*logn)； 最坏：O(n^2)
- 空间复杂度：平均：O(logn)，递归调用开辟栈空间；最坏：O(n)，每次切分元素都是当前最大或最小值，则数组需要切分n次

#### 快排的改进

- 当数组切分到比较小的时候（5～15），该用插入排序
- 三取样切分：随机曲阳三个元素，选择中等大小的元素作为切分元素
- 墒最优的排序：将数组切分为三部分，小于、等于、大于

### 堆排序 (Heap)

#### [优先队列](../queue) (MaxPriorityQueue)

- 删除最大元素和插入元素。这种数据类型叫做优先队列

#### 堆
